# --- START OF FILE main.py ---

import sys
import os
import pandas as pd
from PySide6.QtWidgets import (QApplication, QFileDialog, QHeaderView, QWidget,
                               QTableWidgetItem, QVBoxLayout, QHBoxLayout, QGridLayout,
                               QSplitter, QScrollArea, QFrame, QMainWindow, QPushButton,
                               QComboBox, QTableWidget, QLabel, QLineEdit, QToolButton,
                               QMessageBox)
from PySide6.QtCore import Qt, Signal, QSize, QRect, QMargins
from PySide6.QtGui import QIcon, QFont

from qfluentwidgets import (FluentWindow, NavigationItemPosition, SplashScreen,
                            FluentIcon, setTheme, Theme, SubtitleLabel, PushButton,
                            ComboBox, TableWidget, MessageBox, InfoBar, InfoBarPosition,
                            ToolButton, FluentStyleSheet, LineEdit, ScrollArea,
                            ExpandLayout, isDarkTheme, SmoothScrollArea)
from qfluentwidgets import FlowLayout


class ExcelMatchWindow(FluentWindow):
    """Excel多条件多sheet查询工具主窗口"""

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Excel多条件多sheet查询")
        self.resize(1400, 800)

        # 数据存储
        self.excel_file = None
        self.sheets = {}
        self.selected_sheets = []
        self.query_fields = []
        self.match_fields = []
        self.result_data = None
        
        # 界面响应式布局
        self.splitter = None
        self.leftWidget = None
        self.rightWidget = None

        # 初始化UI
        self._initUI()
        self._connectSignalToSlot()
        
        # 窗口大小变化时重新调整布局
        self.resizeEvent = self.onResize

    def _initUI(self):
        """初始化UI"""
        # 添加导航项
        self.homeInterface = QWidget(self)
        self.homeInterface.setObjectName("homeInterface")

        # 添加子界面
        self.addSubInterface(self.homeInterface, FluentIcon.HOME, "主页", position=NavigationItemPosition.TOP)
        
        # 设置主页布局
        self._initHomeInterface()

    def _initHomeInterface(self):
        """初始化主页界面，使用响应式布局"""
        # 创建主布局
        mainLayout = QVBoxLayout(self.homeInterface)
        mainLayout.setContentsMargins(10, 10, 10, 10)
        mainLayout.setSpacing(5)
        
        # 文件选择区域
        fileAreaLayout = QHBoxLayout()
        fileLabel = SubtitleLabel("Excel文件")
        
        self.filePathEdit = LineEdit()
        self.filePathEdit.setReadOnly(True)
        self.filePathEdit.setPlaceholderText("请选择Excel文件")
        
        self.selectFileButton = PushButton("选择文件")
        
        fileAreaLayout.addWidget(fileLabel)
        fileAreaLayout.addWidget(self.filePathEdit, 1)  # 1表示可伸缩
        fileAreaLayout.addWidget(self.selectFileButton)
        mainLayout.addLayout(fileAreaLayout)
        
        # 创建分割器，左侧为查询配置，右侧为结果显示
        self.splitter = QSplitter(Qt.Horizontal)
        self.splitter.setChildrenCollapsible(False)
        
        # 左侧查询配置区域
        self.leftWidget = QWidget()
        leftLayout = QVBoxLayout(self.leftWidget)
        leftLayout.setContentsMargins(0, 0, 5, 0)
        
        # 工作表选择区域 - 使用滚动区域
        sheetSelectionLabel = SubtitleLabel("选择要查询的工作表")
        leftLayout.addWidget(sheetSelectionLabel)
        
        self.sheetSelectionScroll = SmoothScrollArea()
        self.sheetSelectionScroll.setWidgetResizable(True)
        
        sheetSelectionWidget = QWidget()
        self.sheetSelectionLayout = QVBoxLayout(sheetSelectionWidget)
        self.sheetSelectionLayout.setContentsMargins(5, 5, 5, 5)
        self.sheetSelectionLayout.setSpacing(5)
        self.sheetSelectionLayout.addStretch(1)  # 添加弹性空间，使内容靠上
        
        self.sheetSelectionScroll.setWidget(sheetSelectionWidget)
        leftLayout.addWidget(self.sheetSelectionScroll, 1)
        
        # 添加工作表按钮
        addSheetLayout = QHBoxLayout()
        self.addSheetButton = PushButton("添加工作表")
        self.addSheetButton.setIcon(FluentIcon.ADD)
        self.addSheetButton.setEnabled(False)
        addSheetLayout.addStretch(1)
        addSheetLayout.addWidget(self.addSheetButton)
        leftLayout.addLayout(addSheetLayout)
        
        # 查询条件区域
        queryConditionLabel = SubtitleLabel("设置查询条件")
        leftLayout.addWidget(queryConditionLabel)
        
        self.queryFieldsContainer = QWidget()
        self.queryFieldsContainer.setStyleSheet("""
            QWidget {
                background-color: #f5f5f5;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
        """)
        self.queryFieldsLayout = QVBoxLayout(self.queryFieldsContainer)
        self.queryFieldsLayout.setContentsMargins(5, 5, 5, 5)
        self.queryFieldsLayout.setSpacing(5)
        
        # 添加查询字段按钮
        addQueryButtonContainer = QWidget()
        addQueryButtonLayout = QHBoxLayout(addQueryButtonContainer)
        addQueryButtonLayout.setContentsMargins(0, 0, 0, 0)
        addQueryButtonLayout.setSpacing(5)
        
        self.addQueryButton = ToolButton(FluentIcon.ADD)
        self.addQueryButton.setToolTip("添加查询条件")
        self.addQueryButton.setEnabled(False)
        
        addQueryButtonLayout.addWidget(self.addQueryButton)
        addQueryButtonLayout.addStretch(1)
        
        leftLayout.addWidget(addQueryButtonContainer)
        leftLayout.addWidget(self.queryFieldsContainer)
        
        # 显示字段区域
        displayFieldsLabel = SubtitleLabel("设置显示字段")
        leftLayout.addWidget(displayFieldsLabel)
        
        self.matchFieldsContainer = QWidget()
        self.matchFieldsContainer.setStyleSheet("""
            QWidget {
                background-color: #f8f8f8;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
        """)
        self.matchFieldsLayout = QVBoxLayout(self.matchFieldsContainer)
        self.matchFieldsLayout.setContentsMargins(5, 5, 5, 5)
        self.matchFieldsLayout.setSpacing(5)
        
        # 添加显示字段按钮
        addMatchButtonContainer = QWidget()
        addMatchButtonLayout = QHBoxLayout(addMatchButtonContainer)
        addMatchButtonLayout.setContentsMargins(0, 0, 0, 0)
        addMatchButtonLayout.setSpacing(5)
        
        self.addMatchButton = ToolButton(FluentIcon.ADD)
        self.addMatchButton.setToolTip("添加显示字段")
        self.addMatchButton.setEnabled(False)
        
        addMatchButtonLayout.addWidget(self.addMatchButton)
        addMatchButtonLayout.addStretch(1)
        
        leftLayout.addWidget(addMatchButtonContainer)
        leftLayout.addWidget(self.matchFieldsContainer)
        
        # 执行查询按钮
        executeLayout = QHBoxLayout()
        self.executeQueryButton = PushButton("执行多表查询")
        self.executeQueryButton.setIcon(FluentIcon.SEARCH)
        self.executeQueryButton.setEnabled(False)
        executeLayout.addWidget(self.executeQueryButton)
        leftLayout.addLayout(executeLayout)
        
        # 右侧结果区域
        self.rightWidget = QWidget()
        rightLayout = QVBoxLayout(self.rightWidget)
        rightLayout.setContentsMargins(5, 0, 0, 0)
        
        # 结果标题
        resultTitleLayout = QHBoxLayout()
        self.resultLabel = SubtitleLabel("查询结果")
        resultTitleLayout.addWidget(self.resultLabel)
        resultTitleLayout.addStretch(1)
        rightLayout.addLayout(resultTitleLayout)
        
        # 结果表格
        self.resultTable = TableWidget()
        self.resultTable.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.resultTable.setSortingEnabled(True)
        self.resultTable.setAlternatingRowColors(True)
        rightLayout.addWidget(self.resultTable, 1)  # 1表示可伸缩
        
        # 添加左右两侧部件到分割器
        self.splitter.addWidget(self.leftWidget)
        self.splitter.addWidget(self.rightWidget)
        self.splitter.setSizes([600, 800])  # 设置初始大小比例
        
        # 将分割器添加到主布局
        mainLayout.addWidget(self.splitter, 1)  # 1表示可伸缩
        
        # 初始化数据
        self.query_fields = []  # 查询字段列表，元组 (ComboBox, LineEdit)
        self.match_fields = []  # 显示字段列表，元组 (ComboBox, LineEdit)，LineEdit用于自定义标题

    def _connectSignalToSlot(self):
        """连接信号和槽"""
        self.selectFileButton.clicked.connect(self.selectExcelFile)
        self.addSheetButton.clicked.connect(lambda: self._addSheetSelection())
        self.addQueryButton.clicked.connect(self._addQueryField)
        self.addMatchButton.clicked.connect(self._addMatchField)
        self.executeQueryButton.clicked.connect(self.executeMultiSheetQuery)

    def selectExcelFile(self):
        """选择Excel文件"""
        filePath, _ = QFileDialog.getOpenFileName(
            self, "选择Excel文件", "", "Excel Files (*.xlsx *.xls)")

        if not filePath:
            return

        try:
            self.filePathEdit.setText("正在加载...")
            QApplication.processEvents()

            # 读取Excel文件中的所有工作表
            self.excel_file = filePath

            # 清空之前的数据
            self.sheets = {}
            self.clearResultTable()
            
            # 清空已选择的工作表
            self._clearSheetSelections()
            
            # 清空查询字段和显示字段
            self._clearAllFields()

            # 读取所有工作表
            excel = pd.ExcelFile(filePath)
            sheet_names = excel.sheet_names
            self.sheets = pd.read_excel(filePath, sheet_name=sheet_names)

            # 默认加载所有工作表
            if sheet_names:
                # 自动添加所有工作表
                for sheet_name in sheet_names:
                    self._addSheetSelection(sheet_name)
                
                # 如果已加载所有工作表，则禁用添加按钮
                self.addSheetButton.setEnabled(False)
                
                # 自动添加一个查询条件和一个显示字段
                self._addQueryField()
                self._addMatchField()
            else:
                self.addSheetButton.setEnabled(False)
            
            # 更新字段按钮状态
            self._updateExecuteButtonState()

            self.filePathEdit.setText(filePath)

            # 显示成功消息
            InfoBar.success(
                title="成功",
                content=f"已加载Excel文件: {os.path.basename(filePath)} ({len(sheet_names)} sheets)",
                parent=self,
                position=InfoBarPosition.TOP,
                duration=3000
            )

        except Exception as e:
            self.filePathEdit.setText("")
            # 打印异常堆栈跟踪，方便调试
            import traceback
            traceback.print_exc()
            MessageBox("错误", f"加载Excel文件时出错: {str(e)}", self).exec()
            
    def _clearSheetSelections(self):
        """清空所有工作表选择"""
        # 清空已选择的工作表
        for combo in self.selected_sheets:
            if combo.parentWidget():
                combo.parentWidget().deleteLater()
        self.selected_sheets = []
        
    def _clearAllFields(self):
        """清空所有字段（查询字段和匹配字段）"""
        self._clearQueryFields()
        self._clearMatchFields()

    def _clearQueryFields(self):
        """清空所有查询字段"""
        # 清空查询字段
        for combo, edit in self.query_fields:
            if combo.parentWidget():
                combo.parentWidget().deleteLater()
        self.query_fields = []
        
    def _clearMatchFields(self):
        """清空所有显示字段"""
        # 清空显示字段
        for combo, edit in self.match_fields:
            if combo.parentWidget():
                combo.parentWidget().deleteLater()
        self.match_fields = []

    def executeMultiSheetQuery(self):
        """执行多工作表查询，实现类似Excel的FILTER(VSTACK(...))功能，支持自定义标题"""
        try:
            # 检查是否有选择的工作表
            if not self.selected_sheets:
                InfoBar.warning(
                    title="无法执行查询",
                    content="请先选择至少一个工作表",
                    parent=self,
                    position=InfoBarPosition.TOP,
                    duration=3000
                )
                return
                
            # 存储所有工作表数据的列表，用于垂直堆叠
            all_dfs = []
            
            # 处理每个选择的工作表
            for i, sheet_combo in enumerate(self.selected_sheets):
                sheet_name = sheet_combo.currentText()
                
                if not sheet_name or sheet_name not in self.sheets:
                    continue  # 跳过无效的工作表
                    
                # 获取当前工作表数据
                current_df = self.sheets[sheet_name].copy()
                
                # 跳过空数据
                if current_df.empty:
                    continue
                    
                # 应用查询条件（每个工作表使用相同的查询条件）
                filtered_df = self._applyQueryConditions(current_df, self.query_fields)
                
                # 跳过筛选后为空的数据
                if filtered_df.empty:
                    continue
                    
                # 添加工作表名称列，方便识别数据来源
                filtered_df['数据来源'] = sheet_name
                
                # 将筛选后的数据添加到列表
                all_dfs.append(filtered_df)
            
            # 如果没有有效数据，显示提示
            if not all_dfs:
                InfoBar.info(
                    title="查询完成",
                    content="未找到匹配记录",
                    parent=self,
                    position=InfoBarPosition.TOP,
                    duration=3000
                )
                self.clearResultTable()
                return
                
            # 垂直堆叠所有数据（类似VSTACK功能）
            try:
                # 使用列对齐方法确保所有DataFrame具有相同的列结构
                aligned_dfs = self._alignDataFrameColumns(all_dfs)
                
                # 垂直堆叠对齐后的DataFrame
                stacked_df = pd.concat(aligned_dfs, ignore_index=True)
            except Exception as e:
                raise ValueError(f"无法垂直堆叠数据: {str(e)}")
                
            # 筛选显示列并应用自定义标题
            # 收集所有显示字段和自定义标题
            display_columns = []
            column_titles = {}
            
            for combo, title_edit in self.match_fields:
                column = combo.currentText()
                custom_title = title_edit.text().strip()
                
                if column and column in stacked_df.columns:
                    display_columns.append(column)
                    
                    # 设置自定义标题（如果有）
                    if custom_title:
                        column_titles[column] = custom_title
                        
            # 如果指定了显示字段，则过滤列
            if display_columns:
                # 确保始终包括"数据来源"列
                if '数据来源' not in display_columns:
                    display_columns.append('数据来源')
                    
                # 确保所有指定的列都存在
                existing_columns = [col for col in display_columns if col in stacked_df.columns]
                if existing_columns:
                    stacked_df = stacked_df[existing_columns]
                    
                    # 应用自定义标题（重命名列）
                    if column_titles:
                        stacked_df = stacked_df.rename(columns=column_titles)
                
            # 显示最终结果
            self.displayResults(stacked_df)
            
        except KeyError as e:
            MessageBox("查询错误", f"列名错误: {str(e)}", self).exec()
            self.clearResultTable()
        except ValueError as e:
            MessageBox("查询错误", f"值错误: {str(e)}", self).exec()
            self.clearResultTable()
        except Exception as e:
            MessageBox("错误", f"执行查询时发生意外错误: {str(e)}", self).exec()
            self.clearResultTable()
            
    def clearResultTable(self):
        """清空结果表格"""
        self.resultTable.clear()
        self.resultTable.setRowCount(0)
        self.resultTable.setColumnCount(0)
        self.result_data = None

    def _applyQueryConditions(self, df, query_fields):
        """应用查询条件到数据框"""
        # 获取有效的查询条件 (有值的查询字段)
        active_query_fields = [(combo.currentText(), edit.text())
                              for combo, edit in query_fields if edit.text().strip()]
                              
        # 如果没有有效的查询条件，则返回原数据
        if not active_query_fields:
            return df
            
        # 应用每个查询条件 (AND 逻辑)
        for column, value in active_query_fields:
            if column not in df.columns:
                raise KeyError(f"查询字段中的列 '{column}' 在工作表中不存在")
                
            try:
                # 对不同类型的列使用适当的比较方法
                if pd.api.types.is_numeric_dtype(df[column]) or pd.api.types.is_datetime64_any_dtype(df[column]):
                    condition = df[column].astype(str).str.contains(value, case=False, na=False)
                else:
                    condition = df[column].str.contains(value, case=False, na=False)
                df = df[condition]
            except AttributeError:
                # 对于其他类型的列，强制转换为字符串后比较
                df = df[df[column].astype(str).str.contains(value, case=False, na=False)]
                
        return df
        
    def _applyDisplayColumns(self, df, match_fields):
        """应用显示字段到数据框"""
        # 获取要显示的列
        display_columns = [combo.currentText() for combo in match_fields]
        
        # 如果没有指定显示字段，则返回原数据
        if not display_columns:
            return df
            
        # 检查指定的列是否存在
        missing_cols = [col for col in display_columns if col not in df.columns]
        if missing_cols:
            # 过滤掉不存在的列
            display_columns = [col for col in display_columns if col in df.columns]
            
            # 如果所有指定的列都不存在，则显示警告并返回原数据
            if not display_columns:
                InfoBar.warning(
                    title="注意",
                    content=f"指定的显示字段列不存在",
                    parent=self,
                    duration=5000,
                    position=InfoBarPosition.TOP
                )
                return df
                
            # 显示警告但继续使用存在的列
            InfoBar.warning(
                title="注意",
                content=f"部分显示字段列不存在: {', '.join(missing_cols)}",
                parent=self,
                duration=5000,
                position=InfoBarPosition.TOP
            )
            
        # 返回只包含指定列的数据
        return df[display_columns]

    def onSheetChanged(self, index):
        """工作表变更时的处理"""
        if index < 0 or not self.sheets:
            return

        sheet_name = self.sheetComboBox.currentText()
        if sheet_name not in self.sheets:
             MessageBox("错误", f"找不到工作表 '{sheet_name}' 的数据。", self).exec()
             return

        self.current_sheet = sheet_name
        # Ensure data is a DataFrame
        current_df = self.sheets.get(self.current_sheet)
        if not isinstance(current_df, pd.DataFrame):
             MessageBox("错误", f"工作表 '{sheet_name}' 的数据格式不正确。", self).exec()
             self.columns = []
             # Disable further actions
             self.addQueryFieldButton.setEnabled(False)
             self.addMatchFieldButton.setEnabled(False)
             self.executeQueryButton.setEnabled(False)
             return

        self.columns = list(current_df.columns)

        # 清空之前的查询和匹配字段
        self._clearAllFields()
        self.clearResultTable()

        # 启用添加字段按钮 if columns exist
        has_columns = bool(self.columns)
        self.addQueryFieldButton.setEnabled(has_columns)
        self.addMatchFieldButton.setEnabled(has_columns)
        # Execute button should only be enabled when fields are added
        self.executeQueryButton.setEnabled(False)

    def _addSheetSelection(self, sheet_name=None):
        """添加要查询的工作表选择"""
        if not self.sheets:
            return
            
        # 创建工作表选择组件
        sheetWidget = QWidget()
        layout = QHBoxLayout(sheetWidget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        
        comboBox = ComboBox()
        # 如果指定了工作表名称，只添加该工作表；否则添加所有工作表
        if sheet_name:
            comboBox.addItem(sheet_name)
        else:
            # 获取未选择的工作表列表
            unselected_sheets = self._getUnselectedSheets()
            if not unselected_sheets:
                # 如果没有未选择的工作表，不执行任何操作
                sheetWidget.deleteLater()
                return
            comboBox.addItems(unselected_sheets)
            # 默认选择第一个未选择的工作表
            sheet_name = unselected_sheets[0]
            
        comboBox.setMinimumWidth(200)
        comboBox.currentIndexChanged.connect(self._updateExecuteButtonState)
        
        removeButton = ToolButton(FluentIcon.DELETE)
        removeButton.setToolTip("移除此工作表")
        removeButton.setIconSize(QSize(14, 14))
        removeButton.clicked.connect(lambda: self._removeSheetSelection(sheetWidget))
        
        layout.addWidget(comboBox)
        layout.addWidget(removeButton)
        layout.addStretch(1)
        
        # 将组件添加到布局
        self.sheetSelectionLayout.insertWidget(self.sheetSelectionLayout.count() - 1, sheetWidget)
        
        # 保存选择的工作表
        self.selected_sheets.append(comboBox)
        
        # 更新添加按钮状态
        self._updateAddSheetButtonState()
        
        # 更新执行按钮状态
        self._updateExecuteButtonState()
        
    def _removeSheetSelection(self, widget):
        """移除工作表选择"""
        # 不允许删除所有工作表
        if len(self.selected_sheets) <= 1:
            InfoBar.warning(
                title="无法删除",
                content="至少需要保留一个工作表",
                parent=self,
                position=InfoBarPosition.TOP,
                duration=3000
            )
            return
            
        # 查找组件在列表中的索引
        found_index = -1
        for i, combo in enumerate(self.selected_sheets):
            if combo.parentWidget() == widget:
                found_index = i
                break
                
        if found_index != -1:
            # 从列表中移除
            self.selected_sheets.pop(found_index)
            
            # 从布局中移除并删除组件
            self.sheetSelectionLayout.removeWidget(widget)
            widget.deleteLater()
            
            # 更新添加按钮状态
            self._updateAddSheetButtonState()
            
            # 更新执行按钮状态
            self._updateExecuteButtonState()
    
    def _getUnselectedSheets(self):
        """获取未被选择的工作表列表"""
        if not self.sheets:
            return []
            
        # 所有工作表
        all_sheets = list(self.sheets.keys())
        
        # 已选择的工作表
        selected = []
        for combo in self.selected_sheets:
            selected.append(combo.currentText())
            
        # 返回未选择的工作表
        return [sheet for sheet in all_sheets if sheet not in selected]
        
    def _updateAddSheetButtonState(self):
        """更新添加工作表按钮状态"""
        # 如果还有未选择的工作表，则启用添加按钮
        has_unselected = bool(self._getUnselectedSheets())
        self.addSheetButton.setEnabled(has_unselected)

    def _addQueryField(self):
        """添加查询字段"""
        if not self.sheets or not self.selected_sheets:
            return
        
        # 获取所有选择的工作表中的列
        columns = self._getCommonColumns()
        if not columns:
            InfoBar.warning(
                title="无法添加查询字段",
                content="所选工作表没有共同的列",
                parent=self,
                position=InfoBarPosition.TOP,
                duration=3000
            )
            return
            
        # 创建字段选择器组件
        fieldWidget = QWidget()
        layout = QHBoxLayout(fieldWidget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        
        comboBox = ComboBox()
        comboBox.addItems(columns)
        comboBox.setMinimumWidth(120)
        # 默认选择第一个字段
        if columns:
            comboBox.setCurrentIndex(0)
        
        valueEdit = LineEdit()
        valueEdit.setPlaceholderText("包含值 (文本)")
        valueEdit.setMinimumWidth(100)
        valueEdit.setClearButtonEnabled(True)
        
        removeButton = ToolButton(FluentIcon.DELETE)
        removeButton.setToolTip("移除此查询条件")
        removeButton.setIconSize(QSize(14, 14))
        removeButton.clicked.connect(lambda: self._removeQueryField(fieldWidget))
        
        layout.addWidget(comboBox)
        layout.addWidget(valueEdit)
        layout.addWidget(removeButton)
        layout.addStretch(1)
        
        # 将字段组件添加到查询字段容器
        self.queryFieldsLayout.addWidget(fieldWidget)
        self.query_fields.append((comboBox, valueEdit))
        
        # 更新执行按钮状态
        self._updateExecuteButtonState()
    
    def _removeQueryField(self, widget):
        """移除查询字段"""
        # 查找组件在列表中的索引
        found_index = -1
        for i, (combo, edit) in enumerate(self.query_fields):
            if combo.parentWidget() == widget:
                found_index = i
                break
                
        if found_index != -1:
            # 从列表中移除
            self.query_fields.pop(found_index)
            
            # 从布局中移除并删除组件
            self.queryFieldsLayout.removeWidget(widget)
            widget.deleteLater()
            
            # 更新执行按钮状态
            self._updateExecuteButtonState()
    
    def _addMatchField(self):
        """添加显示字段"""
        if not self.sheets or not self.selected_sheets:
            return
            
        # 获取所有选择的工作表中的列
        columns = self._getCommonColumns()
        if not columns:
            InfoBar.warning(
                title="无法添加显示字段",
                content="所选工作表没有共同的列",
                parent=self,
                position=InfoBarPosition.TOP,
                duration=3000
            )
            return
            
        # 创建字段选择器组件
        fieldWidget = QWidget()
        layout = QHBoxLayout(fieldWidget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        
        comboBox = ComboBox()
        comboBox.addItems(columns)
        comboBox.setMinimumWidth(120)
        # 默认选择第一个字段
        if columns:
            comboBox.setCurrentIndex(1)
        
        # 添加自定义标题输入框
        titleEdit = LineEdit()
        titleEdit.setPlaceholderText("自定义标题（可选）")
        titleEdit.setMinimumWidth(100)
        titleEdit.setClearButtonEnabled(True)
        
        removeButton = ToolButton(FluentIcon.DELETE)
        removeButton.setToolTip("移除此显示字段")
        removeButton.setIconSize(QSize(14, 14))
        removeButton.clicked.connect(lambda: self._removeMatchField(fieldWidget))
        
        layout.addWidget(comboBox)
        layout.addWidget(titleEdit)
        layout.addWidget(removeButton)
        layout.addStretch(1)
        
        # 将字段组件添加到显示字段容器
        self.matchFieldsLayout.addWidget(fieldWidget)
        self.match_fields.append((comboBox, titleEdit))
        
        # 更新执行按钮状态
        self._updateExecuteButtonState()
    
    def _removeMatchField(self, widget):
        """移除显示字段"""
        # 查找组件在列表中的索引
        found_index = -1
        for i, (combo, edit) in enumerate(self.match_fields):
            if combo.parentWidget() == widget:
                found_index = i
                break
                
        if found_index != -1:
            # 从列表中移除
            self.match_fields.pop(found_index)
            
            # 从布局中移除并删除组件
            self.matchFieldsLayout.removeWidget(widget)
            widget.deleteLater()
            
            # 更新执行按钮状态
            self._updateExecuteButtonState()
    
    def _getCommonColumns(self):
        """获取所有选择的工作表中的共同列，保持第一个工作表中列的原始顺序"""
        if not self.selected_sheets:
            return []
            
        # 获取每个选择的工作表的列
        sheet_columns = []
        first_sheet_columns_ordered = []
        
        # 首先处理第一个工作表，记录其列的顺序
        if self.selected_sheets:
            first_sheet_name = self.selected_sheets[0].currentText()
            if first_sheet_name and first_sheet_name in self.sheets:
                first_df = self.sheets[first_sheet_name]
                if isinstance(first_df, pd.DataFrame) and not first_df.empty:
                    # 记录第一个工作表的列顺序
                    first_sheet_columns_ordered = list(first_df.columns)
                    # 将第一个工作表的列添加到列集合中
                    sheet_columns.append(set(first_sheet_columns_ordered))
        
        # 然后处理其他工作表
        for i in range(1, len(self.selected_sheets)):
            combo = self.selected_sheets[i]
            sheet_name = combo.currentText()
            if sheet_name and sheet_name in self.sheets:
                df = self.sheets[sheet_name]
                if isinstance(df, pd.DataFrame) and not df.empty:
                    sheet_columns.append(set(df.columns))
        
        # 如果没有有效的工作表，返回空列表
        if not sheet_columns:
            return []
            
        # 获取所有工作表的共同列
        common_columns_set = set.intersection(*sheet_columns)
        
        # 按照第一个工作表的列顺序排序共同列
        common_columns_ordered = [col for col in first_sheet_columns_ordered if col in common_columns_set]
        
        return common_columns_ordered
        
    def _updateExecuteButtonState(self):
        """更新执行查询按钮状态"""
        # 检查是否有选择的工作表
        has_sheets = bool(self.selected_sheets)
        
        # 更新执行按钮状态
        self.executeQueryButton.setEnabled(has_sheets)
        
        # 更新添加字段按钮状态
        if has_sheets:
            # 检查是否有共同列
            has_common_columns = bool(self._getCommonColumns())
            self.addQueryButton.setEnabled(has_common_columns)
            self.addMatchButton.setEnabled(has_common_columns)
        else:
            self.addQueryButton.setEnabled(False)
            self.addMatchButton.setEnabled(False)

    def displayResults(self, df):
        """显示查询结果"""
        # 保存结果数据
        self.result_data = df

        # 清空表格
        self.resultTable.clear() # Clear headers too

        if df.empty:
            self.resultTable.setRowCount(0)
            self.resultTable.setColumnCount(0)
            InfoBar.info( # Use Info level for "no results"
                title="查询完成",
                content="未找到匹配记录",
                parent=self,
                position=InfoBarPosition.TOP,
                duration=3000
            )
            return

        # 设置表格列数和标题
        columns = list(df.columns)
        col_count = len(columns)
        self.resultTable.setColumnCount(col_count)
        self.resultTable.setHorizontalHeaderLabels(columns)

        # 设置表格行数
        row_count = len(df)
        self.resultTable.setRowCount(row_count)

        # 填充数据
        # Using itertuples for potentially better performance than iloc in loop
        for row_idx, data_row in enumerate(df.itertuples(index=False, name=None)):
            for col_idx in range(col_count):
                value = data_row[col_idx]
                # Convert value to string for QTableWidgetItem
                # Handle None/NaN gracefully
                if pd.isna(value):
                    item_text = ""
                else:
                    item_text = str(value)

                # *** Use QTableWidgetItem ***
                table_item = QTableWidgetItem(item_text)
                # Optional: Align numbers to the right?
                # if isinstance(value, (int, float)):
                #    table_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)

                self.resultTable.setItem(row_idx, col_idx, table_item)

        # Adjust columns after populating (optional, can be slow for many cols)
        # self.resultTable.resizeColumnsToContents()
        # Stretch last section or use Interactive mode (set earlier)

        # 显示结果统计
        InfoBar.success(
            title="查询完成",
            content=f"共找到 {row_count} 条匹配记录",
            parent=self,
            position=InfoBarPosition.TOP,
            duration=3000
        )

    def _alignDataFrameColumns(self, dataframes):
        """对齐多个DataFrame的列，确保可以垂直堆叠
        
        策略:
        1. 找出所有DataFrame中的所有唯一列
        2. 对于每个DataFrame，添加缺失的列并填充NaN
        3. 返回列对齐后的DataFrame列表
        """
        if not dataframes:
            return []
            
        # 收集所有数据框中的所有列
        all_columns = set()
        for df in dataframes:
            all_columns.update(df.columns)
            
        # 对每个数据框添加缺失的列
        aligned_dfs = []
        for df in dataframes:
            # 找出当前数据框缺失的列
            missing_columns = all_columns - set(df.columns)
            
            # 如果有缺失的列，创建一个新的数据框并添加缺失的列
            if missing_columns:
                # 创建一个新的数据框，包含原始列和缺失的列
                new_df = df.copy()
                for col in missing_columns:
                    new_df[col] = pd.NA  # 使用pandas的NA表示缺失值
                aligned_dfs.append(new_df)
            else:
                # 如果没有缺失的列，直接使用原始数据框
                aligned_dfs.append(df)
                
        return aligned_dfs

    def onResize(self, event):
        """窗口大小变化时的处理"""
        # 调用父类的resizeEvent
        super().resizeEvent(event)
        
        # 根据窗口大小调整分割器的大小比例
        if self.splitter:
            width = self.width()
            if width < 800:
                # 小窗口时，左侧占比更大
                self.splitter.setSizes([int(width * 0.6), int(width * 0.4)])
            else:
                # 大窗口时，右侧占比更大
                self.splitter.setSizes([int(width * 0.4), int(width * 0.6)])


def main():
    # 启用高DPI支持
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)

    # 创建应用程序
    app = QApplication(sys.argv)

    # 设置应用程序主题
    setTheme(Theme.AUTO)

    # 创建并显示主窗口
    window = ExcelMatchWindow()
    window.show()

    # 运行应用程序
    sys.exit(app.exec())


if __name__ == "__main__":
    main()

# --- END OF FILE main.py ---